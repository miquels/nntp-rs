# nntp-rs configuration file.

server {
    # Address/port to listen on.
    # ':port' is ipv4+ipv6, '*:port' is ipv4-only, '[::]:port' is ipv6-only.
    listen :1119;

    # User and group to setuid/setgid to after start.
    user news;
    group news;

    # Runtime to use. 'threaded' with 'blocking_io threadpool' is the default.
    #runtime threaded {
    #    #blocking_io threadpool;
    #}
    #runtime multisingle {
        #threads 12;
        #threads_per_core 2;
        #cores 0,2,4-7
    #}

    # hostname sets the system hostname for banners, logging, etc.
    # also sets the default for xrefhost and pathhost.
    #hostname nntp.example.com;

    # xrefhost has not been implemented yet (needs active file support).
    #xrefhost nntp.example.com;

    # pathhost is the path element that is inserted in front of the Path: header of
    # all articles being received. You can set multiple pathhost elements; each one
    # will be inserted in front if the existing path elements.
    # It's also valid to specify `pathhost pathelem1!pathelem2` which is the
    # exact same as `pathhost pathelem2, pathelem2`.
    #pathhost nntp.example.com;

    # commonpath is like pathhost, but it will only be inserted if it is not
    # present in the path yet. defining multiple elements here makes no sense.
    #commonpath common.example.com;
}

# Paths to the default directories.
# All settings here ('config', 'spool' etc) set internal variables with
# that name that can be interpolated in pathnames.
paths {
    # Configuration files.
    config /etc/news;

    # Articles storage ("spool directory").
    spool /var/spool/news;

    # Logfiles.
    log /var/log/news;

    # Database (history file, active file, metrics).
    db /var/lib/news;

    # Runtime ephemeral files (pid file, unix socket).
    run /run/news;

    # Outgoing queue.
    queue /var/spool/news/outgoing;
}

# Config files usually live in ${config}.
config {
    newsfeeds "${config}/dnewsfeeds";
    spool "${config}/dspool.ctl";
}

# the 'config' section will be replaced by this:
#
# Compatibility with diablo format configuration files. These files
# will be read in addition to the "spool" and "newsfeeds" sections
# of this configuration file.
#compat {
#    # Diablo format dnewsfeeds file.
#    dnewsfeeds "${config}/dnewsfeeds";
#
#    # Diablo format dspool.ctl file.
#    dspool_ctl "${config}/dspool.ctl";
#}

# All relative paths in 'log' are relative to paths::log.
# Log files usually live in ${log}, metrics in ${db}.
#
# Log destinations for 'general' and 'incoming' can be "stdout", "stderr",
# "syslog", or a file. They can also contain the variable "${date}" which
# expands to YYYYMMDD in local time, so the logfile will auto-rotate.
log {
    # General log.
    general syslog;

    # Incoming log; 1 line per incoming article.
    incoming "${log}/incoming.log.${date}";

    # Metrics. Mainly used to persist the values over restarts/reboots, but you
    # can read them directly. Format is JSON.
    #metrics "${db}/metrics.json";

    # Prometheus format metrics. You can export these for example using
    # prometheus' node_exporter's textfile collector. Since the server
    # probably runs as the 'news' user, it may not be able to write to
    # the textfile_collector directory directly. In that case, just leave
    # nntp.prom in ${db}, and create a symlink to it from that directory.
    #prometheus "${db}/nntp.prom";
}

# Not implemented yet.
#active {
#    # Active file location.
#    file "${db}/dactive.kp";
#
#    # Backend to use to read/write/update the active file.
#    # The "diablo" backend writes "dkp" format files.
#    backend "diablo";
#}

# The 'history' file is a key/value database that contains an entry for
# every article in the spool. The key is the article's message-id, the
# value contains the time the articles was received, a few flags, and
# the location of the article in the spool.
history {
    # Location of the history database.
    file "${db}/dhistory";

    # Which backend to use, or, which format.
    backend diablo;

    # For very busy servers it might be useful to keep (part of) the
    # history database in memory permanently. Settings are "index", "all".
    #mlock all;

    # The maximum number of parallel accesses to the history database.
    threads 32;

    # We also keep entries for articles that have already expired from
    # the spool, to prevent receiving duplicates.
    remember 7d;
}

# The spool section defines where the articles are stored.
# This is called 'the spool' or 'the news spool' or 'the article spool'.
#
# You can define it directly in this config file, or if it's
# large/complicated split it off into its own file, then include it:
#
#    spool {
#        include "$config/spool.cfg";
#    }
#
# spool {
#     # Spool definitions are numbered 0..99. Usually you have
#     # a filesystem dedicated to a spool, and you can have multiple
#     # filesystems/spools (often one per disk or volume).
#     spool 0 {
#         # Format of the data in the spool.
#         backend diablo;
#
#         # Location. For diablo best-practice is to use "P.xx" where "xx"
#         # is the number of the spool, but you don't have to.
#         path "${spool}/P.00";
#
#         # Minimum amount of space that must be free in this spool. The
#         # Diablo backend starts an auto-expire (FIFO cleanup thread)
#         # as soon as the amount of space dips under this value, and it
#         # then deletes the oldest articles until minfree * 1.10 space
#         # is available again.
#         minfree 10G;
#
#         # Maxsize sets a maximum size, that is kept automatically.
#         # NOTE: this is the size of the _filesystem_, not of just the
#         # articles in the spool. So if you store anything else big in
#         # the same filesytem, the auto-expire might delete the entire
#         # spool trying to free space. Don't do that.
#         #maxsize 50G;
#
#         # Keeptime is the maximum amount of time the articles are kept.
#         # Articles older than keeptime get deleted automatically.
#         #keeptime 365d;
#
#         # Weight of this spool in a 'spoolgroup'. Every article received is
#         # matched to a spoolgroup, and then written to a spool in that group.
#         # The weight defines how many articles, relative-wise, are written to
#         # this spool. For example, with spools 0, 1, 2 and weights 10, 10, 20,
#         # spool 0 and 1 each get 25% of the articles and spool 2 gets 50%.
#         # Weight defaults to the size of the filesystem containing the spool in GB.
#         #weight 100;
#
#         # Diablo type spools consist of multiple directories containing
#         # large spoolfiles. This setting defines how often a new directory
#         # is created. The diablo default is 10 minutes, but that results
#         # in lots of directories. A few hours to a day is better.
#         #reallocint 1d;
#
#         # The maximum size of one spool file. The diablo format history file
#         # has article offsets stored as a 32 bit number, so this cannot
#         # exceed 4GiB (a bit less to be safe). The default is 1GB, if you want to
#         # stay compatible with diablo keep it under 2GB.
#         #max-file-size 4000M;
#     }
#
#     spool 1 {
#         backend diablo;
#         path "${spool}/P.01";
#         minfree 10G;
#     }
#
#     spool 2 {
#         backend diablo;
#         path "${spool}/P.02";
#         minfree 10G;
#     }
#
#     # A group of spools together form a spoolgroup. You need at least one spoolgroup.
#     # When an article is received, it is matched against all spoolgroups and then
#     # gets assigned to the first matching one.
#     spoolgroup main {
#         # Define the spools that are a member of this group.
#         spool 1, 2, 3;
#
#         # Match the Newsgroups: headers.
#         groups *;
#
#         # Maximum size of an article.
#         #maxsize 64K;
#
#         # Maximum number of groups the article has been crossposted to.
#         #maxcross 16;
#
#         # Hashfeed the message-id of the article has to match.
#         #hashfeed 1/3;
#
#         # Article type matcher.
#         # none, default, control, cancel, mime, binary, uuencode, base64,
#         # binhex, yenc, bommanews, multipart, html, ps, partial, pgp, all.
#         # This works the same as a 'groups' selector, for example:
#         #arttypes all, !binary.
#
#         # If set and the article matches this spoolgroup it gets  accepted, then dropped.
#         #dontstore;
#
#         # If set and the article matches this spoolgroup it gets rejected.
#         #rejectarts;
#     }

# Newsfeeds can be defined directly in the config file, but
# since the configuration of those feeds can get quite large it's
# normally split off into a seperate file (or multiple files).
#newsfeeds {
#    include "${config}/newsfeeds.cfg";
#}

# vim: set ts=4 sw=4 et:
